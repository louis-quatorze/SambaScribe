# Example Tasks for a "Hello, World!" Project

This file outlines a set of tasks for building a simple Next.js project. In this project, the user enters their name in a text box on the Home Page and is then greeted with "Hello, {name}" on a separate Greeting Page.

Here's an example prompt to use to generate this. Note that you'll first want to either provide a detailed set of notes / prd of exactly what to build, or have a two-step process where you have the AI create the spec, then proceed with this step:
Be sure to use an advanced thinking model with this, ideally "Deep Research" from OpenAI but o1-pro, o3-mini, flash-2-thinking, or (maybe?) DeepSeek R1 could work as well. 

``` txt
Create a very very very detailed markdown checklist of all of the stories for this project plan, with one-story-point tasks (with unchecked checkboxes) that break down each story. It is critically important that all of the details to implement this are in this list. Note that a very competent AI Coding Agent will be using this list to autonomously create this application, so be sure not to miss any details whatsoever, no matter how much time and thinking you must do to complete this very challenging but critically important task.
```

After you generate this task list, here is a prompt to use in cursor agent to kick this off (might be useful to put at the end of your cursorrules file as well?)
Probably helpful to just @include the cursor-tasks.md file as well. 
``` txt
Go through each story and task in the .cursor-tasks.md file. Find the next story to work on. Review each unfinished task, correct any issues or ask for clarifications (only if absolutely needed!). Then proceed to create or edit files to complete each task. After you complete all the tasks in the story, update the file to check off any completed tasks. Run builds and commits after each story. Run all safe commands without asking for approval. Continue with each task until you have finished the story, then stop and wait for me to review.
```

---
SambaScribe Project Plan - Detailed One-Story-Point Tasks
I. Core Functionality (Basic Features):



User Story 1: PDF Upload - Initial View

[x] Create a basic HTML structure for the homepage.
[x] Add a <input type="file"> element with the ID pdfUpload.
[x] Label the file input field clearly (e.g., "Upload PDF").
[x] Add basic styling to make the upload area visible and understandable.
[x] Ensure the upload area is prominent on the page.
User Story 2: PDF Upload - Successful

[x] Implement JavaScript to handle the change event on the pdfUpload input.
[x] Send the selected file to a backend endpoint (e.g., /upload).
[x] Implement a basic backend endpoint to receive the PDF file.
[x] Store the uploaded PDF file temporarily on the server.
[x] Send a success response (e.g., 200 OK) back to the frontend upon successful upload.
[x] Display a success message to the user (e.g., "PDF uploaded successfully").
User Story 3: PDF Upload - Invalid File Type

[x] In the frontend JavaScript, check the file.type property to ensure it is "application/pdf".
[x] If the file type is not PDF, display an error message to the user (e.g., "Please upload a PDF file").
[x] Ensure the backend also validates the file type.
[x] If the backend detects an invalid file type, send an appropriate error response (e.g., 400 Bad Request).
[x] Display a specific error message from the backend to the user.
User Story 4: PDF Upload - File Size Limit

[ ] Define a maximum allowed file size (e.g., 10MB).
[ ] In the frontend JavaScript, check the file.size property against the limit.
[ ] If the file size exceeds the limit, display an error message to the user (e.g., "File size exceeds the limit").
[ ] Implement a check on the backend to enforce the file size limit.
[ ] If the backend detects a file exceeding the limit, send an appropriate error response.
[ ] Display a specific error message from the backend to the user.
User Story 5: Notation Interpretation - Basic Success

[ ] Implement a backend function to read the content of the uploaded PDF file.
[ ] Research and integrate a library or method to parse Western drumming notation from the PDF content. (Critical: This requires understanding of common Samba notation conventions. The AI might need access to examples or a grammar definition.)
[ ] Extract relevant musical information from the parsed notation (e.g., rhythmic patterns, note durations, accents).
[ ] Store the extracted notation data in a structured format suitable for the AI model.
User Story 6: Mnemonic Generation - Trigger

[ ] On the backend, after successful notation interpretation, automatically trigger the AI mnemonic generation function.
[ ] Pass the structured notation data to the AI model.
[ ] Handle potential errors during the AI model interaction.
User Story 7: Mnemonic Display - Initial Load

[ ] Implement a backend function to receive the generated mnemonic from the AI model.
[ ] Store the generated mnemonic temporarily on the server, associated with the uploaded file.
[ ] Create a frontend area in the HTML to display the mnemonic (e.g., a <div id="mnemonicDisplay">).
[ ] Upon successful mnemonic generation on the backend, send the mnemonic data to the frontend.
[ ] Use JavaScript to dynamically populate the mnemonicDisplay div with the received mnemonic text.
User Story 8: Mnemonic Display - Clear Presentation

[ ] Apply CSS styling to the mnemonicDisplay div to ensure readability.
[ ] Use appropriate font size, line height, and spacing.
[ ] Consider using code formatting or highlighting if the mnemonic has a specific structure.
User Story 9: Theme Selection - Dropdown Visibility

[ ] Add an HTML <select> element with the ID themeSelect.
[ ] Populate the themeSelect dropdown with the default theme option.
[ ] Add a label for the theme selection (e.g., "Select Theme").
[ ] Apply basic styling to the dropdown.
User Story 10: Theme Selection - Default Theme

[ ] Define a default mnemonic theme on the backend (e.g., "General").
[ ] When the mnemonic is initially generated and sent to the frontend, also send the default theme.
[ ] Set the themeSelect dropdown to the default theme.
User Story 11: Theme Selection - Change Theme

[ ] Implement JavaScript to handle the change event on the themeSelect dropdown.
[ ] When the user selects a new theme, send the selected theme to the backend.
[ ] Implement a backend function to re-generate the mnemonic based on the selected theme.
[ ] Send the updated mnemonic back to the frontend.
[ ] Update the mnemonicDisplay div with the new mnemonic.
User Story 12: English Support - Basic Mnemonic

[ ] Ensure the AI model is configured to generate mnemonics in English by default.
[ ] Verify that the generated mnemonics are in understandable English.
User Story 13: Simple UI - Clear Navigation

[ ] Ensure the homepage clearly guides the user through the upload and mnemonic generation process.
[ ] If additional pages are needed, implement a simple navigation bar.
[ ] Use clear and concise language throughout the UI.
User Story 14: No Customization - UI Indication

[ ] Do not include any UI elements that allow users to directly edit or customize the generated mnemonic text beyond theme selection.
[ ] Ensure the theme selection is the only visible option for modifying the mnemonic output.
II. Performance Features:

User Story 15: PDF Upload Feedback - Loading

[ ] When the user uploads a file, display a visual indicator (e.g., a spinning icon or progress bar) near the upload area.
[ ] Hide the loading indicator after the upload is complete.
User Story 16: Notation Processing Feedback - Loading

[ ] After the PDF is uploaded, display a visual indicator that the notation is being processed.
[ ] Hide the loading indicator after the processing is complete.
User Story 17: Mnemonic Generation Feedback - Loading

[ ] After the notation is processed, display a visual indicator that the mnemonic is being generated.
[ ] Hide the loading indicator after the mnemonic is generated and displayed.
User Story 18: Mnemonic Generation Time - Under Threshold

[ ] Implement performance monitoring on the backend to track the time taken for mnemonic generation.
[ ] Optimize the PDF parsing and AI model interaction to ensure generation time is within a few seconds.
User Story 19: Responsive Design - Desktop Layout

[ ] Use CSS media queries to ensure the application layout is appropriate for desktop screen sizes.
[ ] Test the layout on various desktop resolutions.
User Story 20: Responsive Design - Mobile Layout

[ ] Use CSS media queries to ensure the application layout is appropriate for mobile screen sizes.
[ ] Test the layout on various mobile resolutions.
User Story 21: Basic Error Feedback - Upload Failure

[ ] If the backend returns an error during PDF upload (other than invalid type or size), display a generic error message (e.g., "Error uploading PDF. Please try again.").
User Story 22: Basic Error Feedback - Notation Parse Failure

[ ] If the backend fails to parse the notation, display a message indicating this (e.g., "Could not interpret the drumming notation. Please ensure the PDF is correctly formatted.").
User Story 23: Break Name Themes - Presence Check

[ ] During notation parsing, implement logic to identify potential break names within the notation (this will require understanding common notation conventions for breaks).
[ ] Store the identified break names.
User Story 24: Break Name Themes - Dropdown Option

[ ] When populating the themeSelect dropdown, dynamically add options for each identified break name from the notation.
User Story 25: Predefined Themes - List Population

[ ] Define a list of predefined mnemonic themes on the backend (e.g., "Rhythm Focus", "Instrument Sounds", "Samba Vocabulary").
[ ] Populate the themeSelect dropdown with these predefined themes.
III. Excitement Features (Lower Priority for Initial Development):

User Story 26: Brazilian Portuguese - Mnemonic Generation

[ ] Add an option to select the language (English, Brazilian Portuguese) in the UI.
[ ] When Brazilian Portuguese is selected, configure the AI model to generate mnemonics in that language.
[ ] Ensure the AI model is capable of generating coherent mnemonics in Brazilian Portuguese.
User Story 27: Learning Adaptation - Data Collection

[ ] Implement basic analytics to track which themes users select for specific notation.
[ ] Store this data anonymously on the backend.
User Story 28: Learning Adaptation - Preference Identification

[ ] Implement logic on the backend to analyze the collected data and identify potential theme preferences for different types of Samba rhythms.
[ ] Potentially suggest relevant themes to the user based on the uploaded notation.
IV. Non-Functional Requirements (Can be broken down further for testing):

User Story 29: Performance Testing - Mnemonic Generation Load

[ ] Set up a testing environment to simulate concurrent users.
[ ] Define a specific number of concurrent users to test against.
[ ] Measure the average mnemonic generation time under load.
[ ] Ensure the system remains responsive and does not crash under load.
User Story 30: Reliability - Error Logging

[ ] Implement a logging system on the backend to record errors and exceptions.
[ ] Include relevant information in the logs (timestamp, user ID if applicable, error message, stack trace).
User Story 31: Reliability - Basic Monitoring

[ ] Implement basic monitoring tools to track application uptime and basic server health metrics.
V. Won't Have (Explicitly Excluded):

User Story 32: Pre-built Beats - Absence

[ ] Ensure there is no functionality or UI elements related to pre-built mnemonics for popular Samba beats.
User Story 33: Custom Mnemonic Style - Absence

[ ] Ensure there are no UI elements that allow users to directly edit the generated mnemonic text beyond theme selection.
Critical Considerations for the AI Coding Agent:

Samba Drumming Notation: The AI will need a solid understanding of Western drumming notation as applied to Samba. This includes understanding symbols for different drums, rhythms, accents, and common Samba patterns. Providing examples of Samba drumming notation in PDF format would be extremely beneficial.
AI Model Integration: The PRD mentions OpenAI Mini or Claude. The AI Agent will need to research and integrate with the chosen AI model's API. It will need to understand how to send the notation data to the model and receive the generated mnemonic.
Theme Logic: The AI needs to be able to generate different mnemonics based on the selected theme. This implies the AI model needs to be instructed on how to incorporate themes into its mnemonic generation process.
Error Handling: Robust error handling is crucial, both on the frontend and backend, to provide a good user experience.
Asynchronous Operations: Many of the operations (file upload, notation processing, AI generation) will be asynchronous. The AI Agent needs to handle these correctly using Promises or similar mechanisms.
Backend Language and Framework: The PRD doesn't specify a backend language or framework. The AI Agent will need to choose one (e.g., Python/Flask, Node.js/Express) and implement the backend logic accordingly.
Frontend Framework (Optional): While not strictly required, using a frontend framework like React or Vue.js might simplify development, especially for managing state and UI updates.
Security (Basic): While the PRD mentions no specific data privacy measures for uploaded sheets in the MVP, basic security considerations like preventing malicious file uploads should be addressed.